name: Validate & Release

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (örn: v1.0.2)'
        required: false
        default: ''
      create_release:
        description: 'GitHub Release oluştur?'
        required: true
        type: boolean
        default: false

jobs:
  # ─────────────────────────────────────────────
  # 1. JSON Validation
  # ─────────────────────────────────────────────
  validate-json:
    name: Validate JSON
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Validate all JSON files
        run: |
          set -euo pipefail
          FAILED=0

          while IFS= read -r file; do
            if python3 -c "import json,sys; json.load(open(sys.argv[1]))" "$file" 2>/dev/null; then
              echo "OK: $file"
            else
              echo "FAIL: $file"
              python3 -c "
import json, sys
try:
    json.load(open(sys.argv[1]))
except json.JSONDecodeError as e:
    print('  Error:', e)
" "$file" 2>/dev/null || true
              FAILED=1
            fi
          done < <(find data _pre_1_21_4 -1_21_4 1_21_6 pack.mcmeta -name "*.json" -o -name "pack.mcmeta" 2>/dev/null | sort)

          if [ $FAILED -ne 0 ]; then
            echo "FAILED: One or more JSON files are invalid."
            exit 1
          fi
          echo "PASSED: All JSON files are valid."

  # ─────────────────────────────────────────────
  # 2. pack.mcmeta Structural Validation
  # ─────────────────────────────────────────────
  validate-pack:
    name: Validate pack.mcmeta
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Validate pack.mcmeta structure
        run: |
          cat > /tmp/check_pack.py << 'PYEOF'
import json, os, sys

FAILED = False

with open("pack.mcmeta") as f:
    data = json.load(f)

if "pack" not in data:
    print("FAIL: Missing 'pack' key")
    sys.exit(1)

pack = data["pack"]

for key in ["pack_format", "description"]:
    if key not in pack:
        print(f"FAIL: Missing pack.{key}")
        FAILED = True
    else:
        print(f"OK: pack.{key} = {pack[key]!r}" if key == "pack_format" else f"OK: pack.{key} present")

if "supported_formats" in pack:
    sf = pack["supported_formats"]
    fmt = pack.get("pack_format")
    if isinstance(sf, list) and fmt not in sf:
        print(f"WARN: pack_format ({fmt}) not in supported_formats {sf}")
    else:
        print(f"OK: supported_formats = {sf}")

if "overlays" in data:
    entries = data["overlays"].get("entries", [])
    print(f"OK: overlays = {len(entries)} entries")
    for entry in entries:
        d = entry.get("directory", "")
        if not d:
            print("FAIL: Overlay entry missing 'directory' key")
            FAILED = True
        elif not os.path.isdir(d):
            print(f"FAIL: Overlay directory not found: {d}/")
            FAILED = True
        else:
            fmt_range = entry.get("formats", {})
            min_f = fmt_range.get("min_inclusive", "?")
            max_f = fmt_range.get("max_inclusive", "?")
            print(f"OK: {d}/ (formats {min_f}-{max_f})")

if FAILED:
    sys.exit(1)
print("PASSED: pack.mcmeta is valid.")
PYEOF
          python3 /tmp/check_pack.py

  # ─────────────────────────────────────────────
  # 3. Function Reference Integrity
  # ─────────────────────────────────────────────
  validate-functions:
    name: Validate Function References
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check function references in tags
        run: |
          cat > /tmp/check_functions.py << 'PYEOF'
import json, os, glob, sys

FAILED = False

def ns_to_path(ref, base_dirs):
    if ref.startswith("#") or ":" not in ref:
        return None
    ns, path = ref.split(":", 1)
    for base in base_dirs:
        full = os.path.join(base, "data", ns, "function", path + ".mcfunction")
        if os.path.exists(full):
            return full
    return None

base_dirs = [".", "_pre_1_21_4", "-1_21_4", "1_21_6"]
tag_files = glob.glob("**/tags/function/**/*.json", recursive=True)

for tag_file in tag_files:
    with open(tag_file) as f:
        try:
            data = json.load(f)
        except json.JSONDecodeError:
            continue
    for ref in data.get("values", []):
        if isinstance(ref, dict):
            ref = ref.get("id", "")
        if not ref or ref.startswith("#"):
            continue
        if ns_to_path(ref, base_dirs):
            print(f"OK: {ref}")
        else:
            print(f"FAIL: {tag_file} -> '{ref}' not found")
            FAILED = True

if FAILED:
    print("FAILED: Some function references are missing.")
    sys.exit(1)
print("PASSED: All function references are valid.")
PYEOF
          python3 /tmp/check_functions.py

      - name: Check for empty .mcfunction files
        run: |
          EMPTY=0
          while IFS= read -r file; do
            content=$(grep -v '^\s*#' "$file" | grep -v '^\s*$' || true)
            if [ -z "$content" ]; then
              echo "WARN: Empty/comment-only: $file"
              EMPTY=$((EMPTY + 1))
            fi
          done < <(find data _pre_1_21_4 -1_21_4 1_21_6 -name "*.mcfunction" 2>/dev/null)
          [ $EMPTY -gt 0 ] && echo "WARN: $EMPTY empty files (may be intentional)" || echo "PASSED: No empty .mcfunction files."

  # ─────────────────────────────────────────────
  # 4. Required Files Check
  # ─────────────────────────────────────────────
  validate-structure:
    name: Validate File Structure
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check required files and directories
        run: |
          FAILED=0

          for f in pack.mcmeta pack.png; do
            [ -f "$f" ] && echo "OK: $f" || { echo "FAIL: Missing $f"; FAILED=1; }
          done

          for d in data _pre_1_21_4 -1_21_4 1_21_6; do
            if [ -d "$d" ]; then
              count=$(find "$d" -type f | wc -l)
              echo "OK: $d/ ($count files)"
            else
              echo "FAIL: Missing directory $d/"
              FAILED=1
            fi
          done

          for fn in \
            "data/macro/function/load.mcfunction" \
            "data/macro/function/tick.mcfunction" \
            "data/minecraft/tags/function/load.json" \
            "data/minecraft/tags/function/tick.json"; do
            [ -f "$fn" ] && echo "OK: $fn" || { echo "FAIL: Missing $fn"; FAILED=1; }
          done

          [ $FAILED -ne 0 ] && { echo "FAILED: Required files missing."; exit 1; }
          echo "PASSED: File structure is complete."

  # ─────────────────────────────────────────────
  # 5. Version Validation
  # ─────────────────────────────────────────────
  validate-version:
    name: Validate Version
    runs-on: ubuntu-latest
    needs: [ validate-json, validate-pack, validate-functions, validate-structure ]
    steps:
      - uses: actions/checkout@v4

      - name: Check version in pack.mcmeta
        run: |
          cat > /tmp/check_version.py << 'PYEOF'
import json, re, sys, os

with open("pack.mcmeta") as f:
    raw = json.dumps(json.load(f))

versions = re.findall(r'v(\d+\.\d+\.\d+)', raw)

if not versions:
    print("WARN: No version string found in pack.mcmeta description.")
else:
    print(f"OK: Version in pack.mcmeta: v{versions[0]}")

tag = os.environ.get("CHECK_TAG", "")
if tag:
    tag = tag.lstrip("v")
    if tag not in versions:
        print(f"FAIL: Tag v{tag} does not match pack.mcmeta versions: {versions}")
        print(f"  Update pack.mcmeta description to 'v{tag}' before releasing.")
        sys.exit(1)
    else:
        print(f"PASSED: v{tag} matches pack.mcmeta.")
PYEOF
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            CHECK_TAG="${{ github.event.inputs.version }}" python3 /tmp/check_version.py
          elif [[ "$GITHUB_REF" == refs/tags/* ]]; then
            CHECK_TAG="${GITHUB_REF#refs/tags/}" python3 /tmp/check_version.py
          else
            python3 /tmp/check_version.py
          fi

      - name: Check CHANGELOG
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            TAG="${{ github.event.inputs.version }}"
          elif [[ "$GITHUB_REF" == refs/tags/* ]]; then
            TAG="${GITHUB_REF#refs/tags/}"
          else
            TAG=""
          fi

          if [ ! -f "docs/CHANGELOG.md" ]; then
            echo "WARN: docs/CHANGELOG.md not found."
          elif [ -z "$TAG" ]; then
            echo "INFO: No tag to check in CHANGELOG."
          elif grep -q "$TAG" docs/CHANGELOG.md; then
            echo "OK: $TAG found in CHANGELOG.md"
          else
            echo "WARN: $TAG not in CHANGELOG.md — consider documenting this release."
          fi

  # ─────────────────────────────────────────────
  # 6. Package & Release
  # ─────────────────────────────────────────────
  release:
    name: Package & Release
    runs-on: ubuntu-latest
    needs: [ validate-json, validate-pack, validate-functions, validate-structure ]
    if: startsWith(github.ref, 'refs/tags/v') || (github.event_name == 'workflow_dispatch' && github.event.inputs.create_release == 'true')
    steps:
      - uses: actions/checkout@v4

      - name: Resolve release tag
        id: tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            TAG="${{ github.event.inputs.version }}"
            if [ -z "$TAG" ]; then
              echo "FAIL: No version provided."
              exit 1
            fi
          else
            TAG="${GITHUB_REF#refs/tags/}"
          fi
          echo "value=$TAG" >> $GITHUB_OUTPUT
          echo "OK: Release tag = $TAG"

      - name: Build datapack ZIP
        run: |
          TAG="${{ steps.tag.outputs.value }}"
          ZIP_NAME="macroEngine-${TAG}.zip"

          zip -r "$ZIP_NAME" \
            data/ \
            _pre_1_21_4/ \
            -1_21_4/ \
            1_21_6/ \
            pack.mcmeta \
            pack.png

          SIZE=$(du -sh "$ZIP_NAME" | cut -f1)
          echo "OK: Built $ZIP_NAME ($SIZE)"
          echo "zip_name=$ZIP_NAME" >> $GITHUB_OUTPUT
        id: build

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.value }}
          name: "macroEngine ${{ steps.tag.outputs.value }}"
          files: ${{ steps.build.outputs.zip_name }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
